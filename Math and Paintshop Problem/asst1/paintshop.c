#include <types.h>
#include <lib.h>
#include <synch.h>
#include <test.h>
#include <thread.h>

#include "paintshop.h"
#include "paintshop_driver.h"


/*
 * **********************************************************************
 * YOU ARE FREE TO CHANGE THIS FILE BELOW THIS POINT AS YOU SEE FIT
 *
*/

/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY CUSTOMER THREADS
 * **********************************************************************
*/

void order_paint(struct paintcan *can);
void go_home();
void * take_order();
void fill_order(void *v);
void serve_order(void *v);
void paintshop_open();
void paintshop_close();

/*
 * order_paint()
 *
 * Takes one argument specifying the can to be filled. The function
 * makes the can available to staff threads and then blocks until the staff
 * have filled the can with the appropriately tinted paint.
 *
 * The can itself contains an array of requested tints.
*/

void order_paint(struct paintcan *can)
{
    /* if order_buffer is full then wait
       else decrement number of empty slots in order_buffer
    */
    P(sem_empty_order_buffer);

    // enter into the critical region
    P(sem_order_paint);

    // put the can in an empty slot in order_buffer
    for(int i=0; i<NCUSTOMERS; i++)
    {
        if(order_buffer[i] == NULL)
        {
            order_buffer[i] = can;
            break;
        }
    }

    // exit critical region
    V(sem_order_paint);

    // increment number of ordered cans
    V(sem_full_order_buffer);


    // look for service
    bool found = false;
    while(1)
    {
        /* if serve_buffer is empty then wait
           else decrement number of ready cans in serve_buffer
        */
        P(sem_full_serve_buffer);

        // enter into the critical region
        P(sem_get_service);

        /* go through the ready cans
           if desired can found then take it
        */
        for(int i=0; i<NCUSTOMERS; i++)
        {
            if(serve_buffer[i] == can)
            {
                serve_buffer[i] = NULL;
                found = true;
                break;
            }
        }

        // exit critical region
        V(sem_get_service);


        if(found)
        {
            // increment number of empty slots in order_buffer
            V(sem_empty_serve_buffer);
            break;
        }
        else
        {
            V(sem_full_serve_buffer);
        }
    }
}

/*
 * go_home()
 *
 * This function is called by customers when they go home. It could be
 * used to keep track of the number of remaining customers to allow
 * paint shop staff threads to exit when no customers remain.
*/

void go_home()
{
    customers--;

    // if no customer left then close shop
    if(customers == 0)  paintshop_close();
}


/*
 * **********************************************************************
 * FUNCTIONS EXECUTED BY PAINT SHOP STAFF THREADS
 * **********************************************************************
*/

/*
 * take_order()
 *
 * This function waits for a new order to be submitted by
 * customers. When submitted, it records the details, and returns a
 * pointer to something representing the order.
 *
 * The return pointer type is void * to allow freedom of representation
 * of orders.
 *
 * The function can return NULL to signal the staff thread it can now
 * exit as their are no customers nor orders left.
*/

void * take_order()
{
    void *can = NULL;

    bool found = false;
    while(1)
    {
        // if no customer left then do nothing
        if(customers == 0)  return  NULL;


        // decrement the number of ordered cans
        P(sem_full_order_buffer);

        // enter into the critical region
        P(sem_get_order);

        // look for any ordered can
        for(int i=0; i<NCUSTOMERS; i++)
        {
            if(order_buffer[i] != NULL)
            {
                can = (void *)order_buffer[i];
                order_buffer[i] = NULL;
                found = true;
                break;
            }
        }

        // exit critical region
        V(sem_get_order);

        if(found)
        {
            // increment number of empty slots in serve_buffer
            V(sem_empty_order_buffer);
            break;
        }
        else
        {
            V(sem_full_order_buffer);
        }
    }

  	return  can;
}


/*
 * fill_order()
 *
 * This function takes an order generated by take order and fills the
 * order using the mix() function to tint the paint.
 *
 * NOTE: IT NEEDS TO ENSURE THAT MIX HAS EXCLUSIVE ACCESS TO THE TINTS
 * IT NEEDS TO USE TO FILE THE ORDER.
*/

void fill_order(void *v)
{
    // access the requested can
    struct paint_can can = (struct paint_can)v;

    // enter into the critical region
    P(sem_fill_order);

    // try to access all the requested colours
    for(int i=0; i<PAINT_COMPLEXITY; i++)
    {
        int col = can->requested_colours[i];

        if(col < 0 || col > NCOLOURS)   continue;

        P(sem_get_tints[col]);
    }

    // exit critical region
    V(sem_fill_order);

    // add tints to can
    mix(can);

    // leave access to all the requested colours
    for(int i=0; i<PAINT_COMPLEXITY; i++)
    {
        int col = can->requested_colours[i];

        if(col < 0 || col > NCOLOURS)   continue;

        V(sem_get_tints[col]);
    }
}

/*
 * serve_order()
 *
 * Takes a filled order and makes it available to the waiting customer.
*/

void serve_order(void *v)
{
    // decrement number of empty slots in serve_buffer
    P(sem_empty_serve_buffer);

    // enter into the critical region
    P(sem_serve_paint);

    // put the ready can in an empty slot in serve_buffer
    for(int i=0; i<NCUSTOMERS; i++)
    {
        if(serve_buffer[i] == NULL)
        {
            serve_buffer[i] = v;
            break;
        }
    }

    // exit critical region
    V(sem_serve_paint);

    // increment number of ready can
    V(sem_full_serve_buffer);
}


/*
 * **********************************************************************
 * INITIALISATION AND CLEANUP FUNCTIONS
 * **********************************************************************
*/

/*
 * paintshop_open()
 *
 * Perform any initialisation you need prior to opening the paint shop to
 * staff and customers
*/

void paintshop_open()
{
	// initialize number of customers
	customers = NCUSTOMERS;

    // customer label binary semaphores for accessing critical region
    sem_order_paint = sem_create("sem_order_paint", 1);
    sem_get_service = sem_create("sem_get_service", 1);

    // stuff label binary semaphores for accessing critical region
    sem_get_order = sem_create("sem_get_order", 1);
    sem_serve_paint = sem_create("sem_serve_paint", 1);
    sem_fill_order = sem_create("sem_fill_order", 1);
    for(int i=0; i<NCOLOURS; i++)
    {
        sem_get_tints[i] = sem_create("sem_get_tints", 1);
    }

    // counting semaphores for controlling access to full or empty buffer
    sem_empty_order_buffer = sem_create("sem_empty_order_buffer", NCUSTOMERS);
    sem_full_order_buffer = sem_create("sem_full_order_buffer", 0);
    sem_empty_serve_buffer = sem_create("sem_empty_serve_buffer", NCUSTOMERS);
    sem_full_serve_buffer = sem_create("sem_full_serve_buffer", 0);

    // initialize order_buffer and serve_buffer
    for(int i=0; i<NCUSTOMERS; i++)
    {
        order_buffer[i] = NULL;
        serve_buffer[i] = NULL;
    }
}

/*
 * paintshop_close()
 *
 * Perform any cleanup after the paint shop has closed and everybody
 * has gone home.
*/

void paintshop_close()
{
    // destroy semaphores
    sem_destroy(sem_order_paint);
    sem_destroy(sem_get_service);

    sem_destroy(sem_get_order);
    sem_destroy(sem_serve_paint);
    sem_destroy(sem_fill_order);
    for(int i=0; i<NCOLOURS; i++)
    {
        sem_destroy(sem_get_tints[i]);
    }

    sem_destroy(sem_empty_order_buffer);
    sem_destroy(sem_full_order_buffer);
    sem_destroy(sem_empty_serve_buffer);
    sem_destroy(sem_full_serve_buffer);
}


